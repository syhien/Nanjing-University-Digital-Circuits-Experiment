
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module exp8(

	//////////// CLOCK //////////
	input 		          		CLOCK2_50,
	input 		          		CLOCK3_50,
	input 		          		CLOCK4_50,
	input 		          		CLOCK_50,

	//////////// KEY //////////
	input 		     [3:0]		KEY,

	//////////// SW //////////
	input 		     [9:0]		SW,

	//////////// LED //////////
	output		     [9:0]		LEDR,

	//////////// Seg7 //////////
	output		     [6:0]		HEX0,
	output		     [6:0]		HEX1,
	output		     [6:0]		HEX2,
	output		     [6:0]		HEX3,
	output		     [6:0]		HEX4,
	output		     [6:0]		HEX5,

	//////////// PS2 //////////
	inout 		          		PS2_CLK,
	inout 		          		PS2_CLK2,
	inout 		          		PS2_DAT,
	inout 		          		PS2_DAT2
);



//=======================================================
//  REG/WIRE declarations
//=======================================================

wire clk;
wire ready;
reg nextdata_n;
wire overflow;
wire [7:0] kb_data;
wire [7:0] ascii_data;
reg [7:0] code_to_show;
reg duanma;
reg pressing;
reg daxie;
integer cnt;
integer daxieoffset;

assign LEDR[1] = duanma;
assign LEDR[0] = pressing;
assign LEDR[2] = daxie;

reg showhex0;
reg showhex1;
reg showhex2;
reg showhex3;

//=======================================================
//  Structural coding
//=======================================================

initial begin
	cnt = 0;
	duanma = 0;
	pressing = 0;
	daxie = 0;
	nextdata_n = 0;
	showhex0 = 0;
	showhex1 = 0;
	showhex2 = 0;
	showhex3 = 0;
	daxieoffset = 0;
end

ps2_keyboard kb (.clk(CLOCK_50), .clrn(SW[0]), .ps2_clk(PS2_CLK), .ps2_data(PS2_DAT), .data(kb_data), .ready(ready), .nextdata_n(nextdata_n), .overflow(overflow));
rom_3 rom_1 (.address(code_to_show), .inclock(CLOCK_50), .q(ascii_data));
hexout hexout_0(.en(showhex0), .data(kb_data[3:0]), .hex(HEX0));
hexout hexout_1(.en(showhex1), .data(kb_data[7:4]), .hex(HEX1));
hexout hexout_2(.en(showhex2), .data(ascii_data[3:0]), .hex(HEX2));
hexout hexout_3(.en(showhex3), .data(ascii_data[7:4] + daxieoffset), .hex(HEX3));
hexout hexout_4(.en(1'b1), .data(cnt % 16), .hex(HEX4));
hexout hexout_5(.en(1'b1), .data(cnt / 16), .hex(HEX5));

always @(negedge CLOCK_50) begin
	if (ready) begin
		nextdata_n <= 0;
		if (duanma == 0 && pressing == 0) begin
			code_to_show = kb_data;
			cnt = cnt + 1;
			showhex0 = 1;
			showhex1 = 1;
			showhex2 = 1;
			if (daxie) begin
				daxieoffset = 2;
			end
			showhex3 = 1;
			duanma <= 0;
			pressing <= 1;
		end
		if (duanma == 0 && pressing == 1) begin
			if (kb_data == 8'b11110000) begin
				duanma <= 1;
				pressing <= 1;
			end
			else begin
				duanma <= 0;
				pressing <= 1;
			end
			showhex0 = 1;
			showhex1 = 1;
			showhex2 = 1;
			if (daxie) begin
				daxieoffset = 2;
			end
			showhex3 = 1;
		end
		if (duanma == 1 && pressing == 1) begin
			if (kb_data == 8'b01011000) begin
				daxie <= ~daxie;
			end
			duanma <= 0;
			pressing <= 0;
			showhex0 = 0;
			showhex1 = 0;
			showhex2 = 0;
			showhex3 = 0;
		end
	end
	cnt = cnt % 256;
end

endmodule

//删掉nextdata
//7段数码管模块化
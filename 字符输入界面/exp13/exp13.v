
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module exp13(

	//////////// CLOCK //////////
	input 		          		CLOCK2_50,
	input 		          		CLOCK3_50,
	input 		          		CLOCK4_50,
	input 		          		CLOCK_50,

	//////////// SW //////////
	input 		     [9:0]		SW,

	//////////// LED //////////
	output		     [9:0]		LEDR,

	//////////// Seg7 //////////
	output		     [6:0]		HEX0,
	output		     [6:0]		HEX1,
	output		     [6:0]		HEX2,
	output		     [6:0]		HEX3,
	output		     [6:0]		HEX4,
	output		     [6:0]		HEX5,

	//////////// VGA //////////
	output		          		VGA_BLANK_N,
	output		     [7:0]		VGA_B,
	output		          		VGA_CLK,
	output		     [7:0]		VGA_G,
	output		          		VGA_HS,
	output		     [7:0]		VGA_R,
	output		          		VGA_SYNC_N,
	output		          		VGA_VS,

	//////////// PS2 //////////
	inout 		          		PS2_CLK,
	inout 		          		PS2_CLK2,
	inout 		          		PS2_DAT,
	inout 		          		PS2_DAT2
);



//=======================================================
//  REG/WIRE declarations
//=======================================================

wire [7:0] kb_ascii;
wire kb_press;

wire clk2;
wire [7:0] cur_ascii;
reg [4:0] wr_hang = 0;
reg [5:0] wr_lie = 0;
reg [7:0] kb_ascii_buf;
reg wren;
reg deleting = 0;

wire [15:0] dots_data;
wire [11:0] color;

wire [9:0] haddr;
wire [9:0] vaddr;
wire [11:0] vgadata;

//=======================================================
//  Structural coding
//=======================================================

keyboard kb (.en(1'b1), .clk(CLOCK_50), .ps2_clk(PS2_CLK), .ps2_data(PS2_DAT), .pressing(kb_press), .q(kb_ascii));

clkgen #(8) clk_2 (CLOCK2_50, 1'b0, 1'b1, clk2);
always @(posedge clk2) begin
	if (wren) begin
		wren = 0;
		wr_lie = wr_lie + 1;
		if (wr_lie == 40) begin
			wr_lie = 0;
			wr_hang = (wr_hang + 1) % 30;
		end
	end
	if (deleting) begin
		deleting = 0;
		if (wr_lie) begin
			wr_lie = wr_lie - 1;
		end 
		else begin
			wr_hang = wr_hang - 1;
			wr_lie = 39;
		end
	end
	if (kb_press) begin
		kb_ascii_buf = kb_ascii;
		case (kb_ascii)
			8'h08: begin//delete
				if (wr_lie || wr_hang) begin
					deleting = 1;
					kb_ascii_buf = 8'h00;
					if (wr_lie) begin
						wr_lie = wr_lie - 1;
					end 
					else begin
						wr_hang = wr_hang - 1;
						wr_lie = 39;
					end
					wren = 1;
				end				
			end
			8'h20: begin//space
				wr_lie = wr_lie + 1;
				if (wr_lie == 40) begin
					wr_lie = 0;
					wr_hang = (wr_hang + 1) % 30;
				end
			end
			8'h0d: begin//enter
				wr_lie = 0;
				wr_hang = (wr_hang + 1) % 30;
			end
			default: begin
				wren = 1;
			end
		endcase
	end
end

dic print_dic (
	.data(kb_ascii_buf), 
	.rdaddress({vaddr[8:4], haddr[9:4]}), 
	.rdclock(CLOCK3_50), 
	.wraddress({wr_hang[4:0], wr_lie[5:0]}), 
	.wrclock(CLOCK4_50), 
	.wren(wren), 
	.q(cur_ascii)
);

ascii2dots ascii_dots(.ascii(cur_ascii), .line(vaddr[3:0]), .dots(dots_data));

clkgen #(25000000) clk_25(.clkin(CLOCK_50), .rst(1'b0), .clken(1'b1), .clkout(VGA_CLK));
assign VGA_SYNC_N = 1'b0;

assign vgadata = dots_data[haddr[3:0]] ? 0 : 12'b111111111111;
vga_ctrl vga(
	.pclk(VGA_CLK),
	.reset(1'b0),
	.vga_data(vgadata),
	.h_addr(haddr),
	.v_addr(vaddr),
	.hsync(VGA_HS),
	.vsync(VGA_VS),
	.valid(VGA_BLANK_N),
	.vga_r(VGA_R),
	.vga_g(VGA_G),
	.vga_b(VGA_B)
);

//test code
hexout h_0(1'b1, kb_ascii[3:0], HEX0);
hexout h_1(1'b1, kb_ascii[7:4], HEX1);
assign LEDR[0] = kb_press;
assign LEDR[1] = clk2;
//assign vgadata = haddr[4] ? 12'b111011010100 : 12'b001011110100;
//test code

endmodule
